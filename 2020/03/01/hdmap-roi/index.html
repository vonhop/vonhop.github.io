<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="apollo5.5 中的高精地图ROI过滤, Just Because">
    <meta name="description" content="（本文出发点以及仍未很好解决的问题是如何从hdmap里面获取roi区域，以及在路口处将每个polygon拼合成一个封闭多边形，如下图：）

（理想的拼接后情况当是如下图：）

一：大致步骤​        建议先阅读apollo文档，以及本">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>apollo5.5 中的高精地图ROI过滤 | Just Because</title>
    <link rel="icon" type="image/png" href="/medias/featureimages/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<link rel="alternate" href="/atom.xml" title="Just Because" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper head-container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <span class="logo-span">Just Because</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <div class="logo-name">Just Because</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/15.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        apollo5.5 中的高精地图ROI过滤
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Apollo/">
                                <span class="chip bg-color">Apollo</span>
                            </a>
                        
                            <a href="/tags/ROI/">
                                <span class="chip bg-color">ROI</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-03-01
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-03-01
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    4.4k
                </div>
                

                
				
                
            </div>
            
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>（本文出发点以及仍未很好解决的问题是如何从hdmap里面获取roi区域，以及在路口处将每个polygon拼合成一个封闭多边形，如下图：）</p>
<p><img src="/images/image-20200301145628900.png" alt=""></p>
<p>（理想的拼接后情况当是如下图：）</p>
<p><img src="/images/image-20200301145728763.png" alt=""></p>
<h2 id="一：大致步骤"><a href="#一：大致步骤" class="headerlink" title="一：大致步骤"></a>一：大致步骤</h2><p>​        建议先阅读<a href="https://github.com/ApolloAuto/apollo/blob/master/docs/specs/3d_obstacle_perception_cn.md">apollo文档</a>，以及本文很大程度上摘抄<a href="https://github.com/YannZyl/Apollo-Note/blob/master/docs/perception/obstacles_lidar_1_hdmap.md">apollo_note</a>，只是针对5.5版本的些许不同以及自身问题出发做的一些总结。</p>
<p>​        函数入口：\perception\lidar\lib\roi_filter\hdmap_roi_filter\hdmap_roi_filter.cc</p>
<h3 id="1、数据转换与ROI生成"><a href="#1、数据转换与ROI生成" class="headerlink" title="1、数据转换与ROI生成"></a>1、数据转换与ROI生成</h3><p>​        获得原始的点云数据==&gt;转换成PCL格式，接着需要从点云中检索ROI区域，这些ROI区域包含路面与路口的驾驶区域。路面与路口的驾驶区域需要查询高精地图来完成，该阶段首先使用tf进行坐标系的转换(lidar坐标系到世界坐标系的变换矩阵)，配合velodyne_pose计算得到velodyne_pose_world(lidar在世界坐标系中的坐标)。真正获取ROI使用的是GetROI函数（5.5版本入口里面这个函数没出现，是直接给了roi的多边形集合，而且有road_polygons和junction_polygons两个集合。GetRoi后面会详述）。</p>
<pre class=" language-C++"><code class="language-C++">hdmap.reset(new HdmapStruct);
hdmap_input_->GetROI(velodyne_pose_world,FLAGS_map_radius, &hdmap);</code></pre>
<h3 id="2、坐标变换"><a href="#2、坐标变换" class="headerlink" title="2、坐标变换"></a>2、坐标变换</h3><blockquote>
<p>Apollo官方文档引用：对于(高精地图ROI)过滤器来说，高精地图数据接口被定义为一系列多边形集合，每个集合由世界坐标系点组成有序点集。高精地图ROI点查询需要点云和多边形处在相同的坐标系，为此，Apollo将输入点云和HDMap多边形变换为来自激光雷达传感器位置的地方坐标系。</p>
</blockquote>
<pre class=" language-C++"><code class="language-C++">TransformFrame(frame->cloud, frame->lidar2world_pose, polygons_world_, &polygons_local_, &cloud_local);</code></pre>
<p>​        坐标变换：将基于lidar坐标系的点云数据、世界坐标系下的polygon，变换成<strong>以lidar为原点的ENU坐标系</strong>。（路口和路面多边形信息只经过平移就可到达新的局部ENU坐标系，可以推测其实世界坐标系也是ENU坐标系，所以两个坐标系之间没有旋转成分；同样lidar坐标系的点云数据变换只需要旋转即可）</p>
<p>​        对于转换到局部ENU坐标系下的必要性：note里说车辆坐标系或者lidar坐标的方向都参考车头的方向，是没有东南西北这些地理位置信息的，可我要这个位置信息有用吗？</p>
<p>​        在全局坐标系下确实也可以（毕竟构造ROI LUT的时候只利用polygon的信息，而polygon变化到ENU坐标系只需要平移），不过后面会有相应的其它变换麻烦。</p>
<h3 id="3、ROI-LUT构造"><a href="#3、ROI-LUT构造" class="headerlink" title="3、ROI LUT构造"></a>3、ROI LUT构造</h3><blockquote>
<p>Apollo官方文档引用：Apollo采用网格显示查找表（LUT），将ROI量化为俯视图2D网格，以此决定输入点是在ROI之内还是之外。LUT覆盖了一个矩形区域，该区域位于高精地图边界上方，以普通视图周围的预定义空间范围为边界。它代表了与ROI关联网格的每个单元格（如用1/0表示在ROI的内部/外部）。为了计算效率，Apollo使用<strong>扫描线算法</strong>和<strong>位图编码</strong>来构建ROI LUT。</p>
</blockquote>
<p>​        <strong>简单地说这个环节的作用就是：将上述转换到局部ENU坐标系下的路面与路口ROI的二维信息映射到一张2D网格图中，网格图中0表示非路口路面区域，1表示路口遇路面区域，最后判断点云cloud中哪些点在路面ROI内(方便做行人，车辆分割)</strong></p>
<p>先解释一下一些基本信息概念：</p>
<ol>
<li>从上面映射到局部ENU坐标系的路口&amp;&amp;路面点云信息，这些点云并不是覆盖所有路口路面区域的，而是路口与路面的凸包，也就是角点。polygons_local里面其实存储了路面与边界线的角点/轮廓信息。cloud_local是所有原始点云映射到ENU局部坐标系过后的信息。</li>
<li>需要将原先路口与路面等多边形的<strong>角点存储模式(节省内存)转换到填充模式</strong>，用到最常用的算法就是扫描线算法。</li>
<li>这个填充模式需要用到一个填充的2d网格，网格的大小范围、网格之间的间距(扫描线之间的大小)等信息，由外部文件定义如下，而最后如何2D网格节省存储开销，就用到了bitmap数据结构：</li>
</ol>
<p><strong>构建过程：</strong></p>
<h4 id="1、Get-Major-Direction-as-X-direction"><a href="#1、Get-Major-Direction-as-X-direction" class="headerlink" title="1、Get Major Direction as X direction"></a>1、Get Major Direction as X direction</h4><p>​        求polygons_local的主方向比较简单，只要计算多边形点云集合中，x/东西方向与y/南北方向最大值与最小值的差，差越大跨度越大。选择跨度小的方向作为主方向。（主方向的用处大概是为了加快扫描线算法速度，跨度小扫描线数就少；其实对每个polygon选一个major_dir更好些？不过采用位图编码的话就没办法了）</p>
<h4 id="2、Convert-polygons-into-roi-grids-in-bitmap"><a href="#2、Convert-polygons-into-roi-grids-in-bitmap" class="headerlink" title="2、Convert polygons into roi grids in bitmap"></a>2、Convert polygons into roi grids in bitmap</h4><blockquote>
<p>入口是DrawPolygonsMask函数，之后是对每个polygon进行了操作，最后每个polygon都会去填充bitmap，而bitmap赋值的时候一直都是用按位的  |= 的，所以应该是哪怕polygon有重复的区域也是没关系的。</p>
</blockquote>
<blockquote>
<p>首先Get valid x range</p>
<p>在bitmap范围和polygon范围里面，选择有效的范围。只关注major_dir方向，两个最小里面选最大/最大里面选最小。将以此范围确定扫描线数。</p>
</blockquote>
<blockquote>
<p>扫描线算法Apollo算法里其实给了两种实现方法，分别是ScansCvt和ScanCvt函数。基本思想都是每条扫描线逐次判断，其中前者是利用将每条线段储存成edge，然后利用edge的每次move判断；而后者是对每条扫描线直接遍历所有线段求交点。本文接下来论述第一种方法，matlab代码里给的是第二种方法。</p>
</blockquote>
<blockquote>
<p>说明：对于每个多边形polygon，其里面存储的<strong>物体的轮廓点是有序的排列的</strong>，所以每两个相邻的点可以构建一条边，最后得到一个封闭的轮廓。</p>
</blockquote>
<p><strong>扫描线算法大致步骤：</strong></p>
<p>1、DisturbPolygon 函数首先将polygon里面的坐标，过于靠近网格线(坐标差值在epsion以内)的点稍微推离网格线。</p>
<p>原因便于步骤3中处理网格线附近的边，经过推离以后，网格线附近的边要么是不穿过网格线，要么就明显的横穿网络，减少那种差一点就横穿网格线的边，降低判断逻辑。</p>
<p>2、ConvertPolygonToSegments函数将多边形相邻的两个点保存出他们的边segment_，同时计算得到这条边的斜率slope。</p>
<p>5.5代码里没有在此处对segment里面每个元素两个点存储的顺序要求其依赖其主方向上的坐标值，即永远是后面一个点的坐标比前面一个点的坐标大（不过后来处理的时候还是加了的，这是用第一种方法必须的）。</p>
<p>​        另外，代码里引入了singular 属性，表示两种特殊情况，分别为斜率为inf以及通过扫描线只有奇数个交点这两种情况。而且singular属性只会在第二种方法中用到，同时，第二种方法不应该对segmen里元素排序。</p>
<p>3、根据主方向上的valid_range(最大坐标和最小坐标差值)，以及网格线间距grid_size，确定扫描线数，然后根据segment里面的两个点计算每条边跟其后面的网格线的第一个交点E，最后转成edge结构，照扫描线编号存到et里面。</p>
<p>​        例外的两种情况分别是第一个交点落在valid_range的两侧，其中将落在左侧的再次判别是否其再往后的交点可以到达第一条扫描线，若可，正常加入et；而落在右侧的部分则直接将其反方向的边界存入top_segment（这里存疑的是我认为只需要根据valid_range的最大值设置一条截线，然后取相交点就可，而代码里则是将右侧所有segment的miny和maxy都存了起来）。</p>
<p>4、根据et，从扫描线id为0开始构建aet，与每根扫描线相交的必有偶数个点（这是因为前面一个对valid_range声称数据稳定性的处理，另一个则是1所说的DisturbPolygon，这也是另外一个方法没做这些处理所以要借助singular属性的原因）。</p>
<p>​        另外，正因为segment里面是排好序的，则步进方向应该都是向右推进；所以参考[1]apollo-note里箭头方向（下图）画的就很有误导…</p>
<p><img src="/images/image-20200301150316121.png" alt=""></p>
<h4 id="3、Draw-grids-in-bitmap-based-on-scan-intervals"><a href="#3、Draw-grids-in-bitmap-based-on-scan-intervals" class="headerlink" title="3、Draw grids in bitmap based on scan intervals"></a>3、Draw grids in bitmap based on scan intervals</h4><p>​        bitmap的数据格式：std::vector<uint64_t> bitmap </uint64_t></p>
<p>​        到最后就是根据上面扫描线算法得到的一系列interval，然后对bitmap赋值了（涉及位运算还是有些迷的…）。其是对列cols除以2^6(64)，因为一个unsigned64有64位，每一位bit存储一个网格0/1值，起到节省开销作用。所以bitmap的大小如果是mxn，那么他可以存储mx64n网格大小的数据。</p>
<p>​        另外这里用到了超参extend_dist，是在每个interval的miny和maxy两头各扩展了一个extend_dist。</p>
<h3 id="4、对每个点检查bitmap，获得roi索引"><a href="#4、对每个点检查bitmap，获得roi索引" class="headerlink" title="4、对每个点检查bitmap，获得roi索引"></a>4、对每个点检查bitmap，获得roi索引</h3><p>​        最后针对每个基于ENU局部坐标系的点云cloud，根据其x和y去bitmap里面做check，第一check该点是否落在这个网格里面(x:[-range,range], y:[-range,range])，这个检查由isExist函数完成；第二个check，如果该点在LUT网格内，那么check这个点是否在路面ROI内，只要检查其对应的网格坐标去bitmap查询即可，1表示在路面；0表示在路面外，这个检查由Check函数完成。</p>
<h2 id="二：额外记录"><a href="#二：额外记录" class="headerlink" title="二：额外记录"></a>二：额外记录</h2><h5 id="看的过程中一直在想开头所说那个拼接的问题，不过确定hdmap那边给的polygon之间会有空隙吗？能不能直接让hdmap那边给我们roi的时候让各区域冗余一些，从而没有空隙（这就不归我们管了，笑）。"><a href="#看的过程中一直在想开头所说那个拼接的问题，不过确定hdmap那边给的polygon之间会有空隙吗？能不能直接让hdmap那边给我们roi的时候让各区域冗余一些，从而没有空隙（这就不归我们管了，笑）。" class="headerlink" title="看的过程中一直在想开头所说那个拼接的问题，不过确定hdmap那边给的polygon之间会有空隙吗？能不能直接让hdmap那边给我们roi的时候让各区域冗余一些，从而没有空隙（这就不归我们管了，笑）。"></a>看的过程中一直在想开头所说那个拼接的问题，不过确定hdmap那边给的polygon之间会有空隙吗？能不能直接让hdmap那边给我们roi的时候让各区域冗余一些，从而没有空隙（这就不归我们管了，笑）。</h5><p>1、base::PointFCloudPool::Instance().Get()</p>
<p>代码里有这样用一个固定数量的池，然后实例化的操作欸。</p>
<p>2、Eigen::Affine3d  T 是一个4*4齐次矩阵变换。</p>
<p>3、polygon的数据结构：typedef PointCloud<pointd> PolygonDType</pointd></p>
<p>4、google glog之CHECK_*含义</p>
<p>#define CHECK_EQ(x,y) CHECK_OP(x,y,EQ,==)<br>#define CHECK_NE(x,y) CHECK_OP(x,y,NE,!=)<br>#define CHECK_LE(x,y) CHECK_OP(x,y,LE,&lt;=)<br>#define CHECK_LT(x,y) CHECK_OP(x,y,LT,&lt;)<br>#define CHECK_GE(x,y) CHECK_OP(x,y,GE,&gt;=)<br>#define CHECK_GT(x,y) CHECK_OP(x,y,GT,&gt;)</p>
<p>5、（uint64_t）-1保证产生0xffffffffffffffff</p>
<p>6、static_cast<int>对应的是下取整。</int></p>
<h2 id="三：hdmap"><a href="#三：hdmap" class="headerlink" title="三：hdmap"></a>三：hdmap</h2><p><strong>问题：roihdmap怎么得到的？就是那些polygons</strong></p>
<h3 id="1、apollo中hdmap格式："><a href="#1、apollo中hdmap格式：" class="headerlink" title="1、apollo中hdmap格式："></a>1、apollo中hdmap格式：</h3><p>（下面每种元素的详细定义都在相应的proto文件里，map文件夹里也有解析的函数）</p>
<pre class=" language-C++"><code class="language-C++">message Map {
  optional Header header = 1;        //上面所说的地图基本信息

  repeated Crosswalk crosswalk = 2;  //人行横道
  repeated Junction junction = 3;    //交叉路口
  repeated Lane lane = 4;           //车道
  repeated StopSign stop_sign = 5;  //停车标志
  repeated Signal signal = 6;       //信号灯
  repeated YieldSign yield = 7;     //让车标志
  repeated Overlap overlap = 8;     //重叠区域
  repeated ClearArea clear_area = 9;  //禁止停车区域
  repeated SpeedBump speed_bump = 10;  //减速带
  repeated Road road = 11;             //道路
  repeated ParkingSpace parking_space = 12; //停车区域
  repeated Sidewalk sidewalk = 13;  //路边的小路，或者行人走的路，现在的版本已经去掉？但是其他模块有些还有sidewalk
}</code></pre>
<p>​        overlap在注释里的解释是“任何一对在地图上重合的东西，包括（车道，路口，人行横道）”，比如路口的人行横道和道路是重叠的，还有一些交通标志和道路也是重叠的，这是创造的一个逻辑概念。</p>
<h3 id="2、map里获得hdmap-roi的函数"><a href="#2、map里获得hdmap-roi的函数" class="headerlink" title="2、map里获得hdmap_roi的函数"></a>2、map里获得hdmap_roi的函数</h3><blockquote>
<p>modules\map\hdmap\hdmap_impl.cc</p>
</blockquote>
<pre class=" language-C++"><code class="language-C++">int HDMapImpl::GetRoi(const apollo::common::PointENU& point, double radius, std::vector<RoadRoiPtr>* roads_roi, std::vector<PolygonRoiPtr>* polygons_roi)</code></pre>
<p>还有一个类似的函数:</p>
<pre class=" language-C++"><code class="language-C++">int HDMap::GetRoadBoundaries(const apollo::common::PointENU& point, double radius, std::vector<RoadROIBoundaryPtr>* road_boundaries, std::vector<JunctionBoundaryPtr>* junctions)</code></pre>
<p>（觉得跟上面那个差不多，不过上面那个多了个停车场？）</p>
<h3 id="3、perception里调用上述函数的入口"><a href="#3、perception里调用上述函数的入口" class="headerlink" title="3、perception里调用上述函数的入口"></a>3、perception里调用上述函数的入口</h3><blockquote>
<p>在modules\perception\map\hdmap\hdmap_input.cc里面用的是GetRoadBoundaries。</p>
</blockquote>
<pre class=" language-C++"><code class="language-C++">bool HDMapInput::GetRoiHDMapStruct(const base::PointD& pointd, const double distance,std::shared_ptr<base::HdmapStruct> hdmap_struct_ptr)</code></pre>
<p>3.1：先用GetRoadBoundaries从hdmap里面获取中心点周围的boundary和junction。</p>
<p>3.2：然后用MergeBoundaryJunction将上面得到的（hdmap里面的格式），转成 这三个：</p>
<p>hdmap_struct_ptr-&gt;junction_polygons;    std::vector<roadboundary> road_boundaries;    hdmap_struct_ptr-&gt;road_polygons;</roadboundary></p>
<p>3.3：最后用GetRoadBoundaryFilteredByJunctions函数（Filter road boundary by junction）</p>
<p>（不过只是过滤hdmap_struct_ptr-&gt;road_boundary，我们hdmap实际用的是hdmap_struct_ptr-&gt;road_polygons。但是里面SplitBoundary函数好像表明road完全覆盖了junction啊，所以split boundary的时候是隔着junction划分成了好几个boundary。）</p>
<p>另：</p>
<blockquote>
<p>modules\perception\lidar\lib\roi_filter\roi_service_filter\roi_service_filter_test.cc    里面这句应该也表明了就是从上面说的函数得到的hdmap_struct<code>CHECK(map::HDMapInput::Instance()&gt;GetRoiHDMapStruct(point, 120.0,frame-&gt;hdmap_struct));</code></p>
</blockquote>
<blockquote>
<p>以及modules\perception\lidar\lib\segmentation\cnnseg\cnn_segmentation.cc里面也有roi_filter的过程</p>
</blockquote>
<h3 id="4、高精地图中的Section、Lane、Junction、road等概念（各处只言片语，自行判断）："><a href="#4、高精地图中的Section、Lane、Junction、road等概念（各处只言片语，自行判断）：" class="headerlink" title="4、高精地图中的Section、Lane、Junction、road等概念（各处只言片语，自行判断）："></a>4、高精地图中的Section、Lane、Junction、road等概念（各处只言片语，自行判断）：</h3><p><img src="/images/image-20200227140638797.png" alt=""></p>
<p><img src="/images/image-20200227140705635.png" alt=""></p>
<p>​        无论车道线变少或变多，都是从中间的灰线切分。切分之后的地图分为Section A、Section B和Section C三部分。一条道路可以被切分为很多个Section。按照道路车道数量变化、道路实线和虚线的变化、道路属性的变化的原则来对道路进行切分。</p>
<p>​        在Lane概念中，Reference Line在OpenDRIVE规范中非常重要。基于Reference Line，向左表示ID向左递增，向右表示ID向右递减，它是格式规范的标准之一，同时也是固定的、不可更改的。比如，Reference Line的ID为0，向左是1、2、3，向右是−1、−2、−3。</p>
<p>​        Junction是OpenDRIVE格式规范中的路口概念。Junction中包含虚拟路，虚拟路用来连接可通行方向，用红色虚线来表示。在一张地图中，在遇到对路口的表述时，虽然说路口没有线，但我们要用虚拟线来连接道路的可通行方向连，以便无人驾驶车辆明确行进路线。</p>
<p>​        <strong>交叉口在OpenDRIVE中并没有形状和实体</strong>，只是表示道路和道路间的连接关系，具体的表述方式如下图</p>
<p><img src="/images/v2-fb13aa42407df95beb13efb76b8e46d2_r.jpg" alt=""></p>
<p><img src="/images/image-20200227142447797.png" alt=""></p>
<p>​        如下图所示，Lane和Junction在空间上有重叠，它们之间就会有Overlap。</p>
<p>​        <strong>这里是说lane和junction有重叠；而不是road和junction</strong></p>
<p><img src="/images/image-20200227142637309.png" alt=""></p>
<p><img src="/images/image-20200227142719596.png" alt=""></p>
<p>​        上图给出了Apollo的车道模型及其相关描述元素。它与openDRIVE大致的规则是一样的，把纵向切成Section，横向还是使用Lane分割。</p>
<p>​        路口表述：路口分为真实路口和十字路口。在实践过程中，发现除了真实路口之外，在车道数变化的时候，比如从两车道变到三车道，<strong>需要感知周围有没有车辆</strong>，在Apollo高精地图里面也把这种情况处理成一个路口。这也是In road和Cross road的区别。</p>
<p><img src="/images/image-20200227142828847.png" alt=""></p>
<h5 id="附：相关几个issue"><a href="#附：相关几个issue" class="headerlink" title="附：相关几个issue"></a>附：相关几个issue</h5><h6 id="The-difference-between-pnc-junction-and-junction-10260"><a href="#The-difference-between-pnc-junction-and-junction-10260" class="headerlink" title="The difference between pnc-junction and junction #10260"></a>The difference between pnc-junction and junction #10260</h6><ul>
<li><strong>junction</strong> is a <strong>rough</strong> area around a junction/intersection. We mainly use it for perception ROI.</li>
<li><strong>pnc-junction</strong> is the junction concept specifically for Planning module. It uses the stop lines of traffic signs(traffic light, stop sign, crosswalk, and etc) as the boundary of the junction. The boundaries are used for decisions and planning in Planning module and must comply with traffic rules.</li>
</ul>
<h6 id="Current-Lane-of-the-Ego-vehicle-6710"><a href="#Current-Lane-of-the-Ego-vehicle-6710" class="headerlink" title="Current Lane of the Ego vehicle #6710"></a>Current Lane of the Ego vehicle #6710</h6><p>​        If you want to get the lane(s) by point, the map may return your multiple lanes since some lanes are overlapped (especially around junctions and turns). This is as expected.<br>​        The lane by point is only unique if you talk about the lanes along the routing. There are some methods inside ReferenceLine class to get it.<a href="https://github.com/ApolloAuto/apollo/blob/master/modules/planning/reference_line/reference_line.h">https://github.com/ApolloAuto/apollo/blob/master/modules/planning/reference_line/reference_line.h</a></p>
<h5 id="闲思："><a href="#闲思：" class="headerlink" title="闲思："></a>闲思：</h5><p>1、我getroad时得到的就是一整段路吗？还是一个路除了其本身有section外，在很外部又有划分呢？</p>
<p>​    提出这个问题是因为，为什么我getroi的时候，getroad之后先检查road-&gt;has_junction_id 如果有的话，就直接存junction的区域了；没有的话才会去存road的boundary。它似乎根本没去按范围检索周围的junction…总之，地图格式因为没实际数据来源还是很迷的…</p>
<p>2、之前好像没考虑过roi过滤为什么不直接判断point在polygon内这样？（笑）</p>
<p>3、最后暂且拼合的方法就是，如果可以的话选每个polygon左右boundary里面最接近junction中心的点，这样每条路得到两个角点；然后需要按照相应的角度顺序排列；最后再次送扫描线算法。（针对我特定的一个样例也只能这种程度，而实际道路又复杂多变…）</p>
<p><img src="/images/image-20200301145912611.png" alt=""></p>
<h6 id="4、matlab"><a href="#4、matlab" class="headerlink" title="4、matlab"></a>4、matlab</h6><pre class=" language-matlab"><code class="language-matlab">补全：tab键
其余操作技巧：
Tab 右移整体代码
Shift<span class="token operator">+</span>Tab 左移整体代码
Ctrl<span class="token operator">+</span>R 注释掉整体代码
Ctrl<span class="token operator">+</span>T 上面的反操作 去掉整体代码前的%
F1显示帮助信息
Ctrl<span class="token operator">+</span>F1显示函数概要信息
Shift<span class="token operator">+</span>F1打开函数浏览器
Ctrl<span class="token operator">+</span>I 自动缩排代码格式
Ctrl<span class="token operator">+</span>D 打开该函数的源代码</code></pre>
<h6 id="主要参考："><a href="#主要参考：" class="headerlink" title="主要参考："></a>主要参考：</h6><p>[1]：Apollo-Note <a href="https://github.com/YannZyl/Apollo-Note/blob/master/docs/perception/obstacles_lidar_1_hdmap.md">https://github.com/YannZyl/Apollo-Note/blob/master/docs/perception/obstacles_lidar_1_hdmap.md</a></p>
<p>[2]：Dig-into-Apollo <a href="https://github.com/daohu527/Dig-into-Apollo/tree/master/map">https://github.com/daohu527/Dig-into-Apollo/tree/master/map</a></p>
<p>[3]：OpenDRIVE <a href="http://www.opendrive.org/index.html">http://www.opendrive.org/index.html</a></p>
<p>[4]：apollo文档 <a href="https://github.com/ApolloAuto/apollo/blob/master/docs/specs/3d_obstacle_perception_cn.md">https://github.com/ApolloAuto/apollo/blob/master/docs/specs/3d_obstacle_perception_cn.md</a></p>
<p>[5]：数据 <a href="https://github.com/ApolloAuto/apollo/issues/5759">https://github.com/ApolloAuto/apollo/issues/5759</a></p>
<p>[6]：扫描线算法 <a href="https://www.jianshu.com/p/d9be99077c2b">https://www.jianshu.com/p/d9be99077c2b</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Apollo/">
                                    <span class="chip bg-color">Apollo</span>
                                </a>
                            
                                <a href="/tags/ROI/">
                                    <span class="chip bg-color">ROI</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2020/08/27/wen-xian-diao-yan-jin-liang-nian-ji-yu-lidar-de-chuan-tong-jian-ce-fang-fa/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="文献调研——近两年基于Lidar的传统检测方法">
                        
                        <span class="card-title">文献调研——近两年基于Lidar的传统检测方法</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            2018[IROS 2018] LiDAR-Based Object Tracking and Shape Estimation Using Polylines and Free-Space Information. [Paper]

大多
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-08-27
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            ChenKe
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Lidar-detection/">
                        <span class="chip bg-color">Lidar detection</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2020/03/01/hdmap-roi/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/15.jpg" class="responsive-img" alt="apollo5.5 中的高精地图ROI过滤">
                        
                        <span class="card-title">apollo5.5 中的高精地图ROI过滤</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            （本文出发点以及仍未很好解决的问题是如何从hdmap里面获取roi区域，以及在路口处将每个polygon拼合成一个封闭多边形，如下图：）

（理想的拼接后情况当是如下图：）

一：大致步骤​        建议先阅读apollo文档，以及本
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-03-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            ChenKe
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Apollo/">
                        <span class="chip bg-color">Apollo</span>
                    </a>
                    
                    <a href="/tags/ROI/">
                        <span class="chip bg-color">ROI</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>

    
<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>

    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    
<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;2019 ChenKe. All Rights Reserved.
     
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">10.7k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            

            <br>
            
            <span id="sitetime"></span>
            <script>
                function siteTime() {
                    window.setTimeout("siteTime()", 1000);
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2019";
                    var startMonth = "12";
                    var startDate = "5";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                        /*
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                    */
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>

            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/vonhop" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:13669262190@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>





    <a href="https://weibo.com/u/5576897044" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/5576897044" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/chen-ke-84-75/activities" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/chen-ke-84-75/activities" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-angle-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->

<script async src="https://www.googletagmanager.com/gtag/js?id=153979208"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
        dataLayer.push(arguments);
    }

    gtag('js', new Date());
    gtag('config', '153979208');
</script>


    <!-- Baidu Analytics -->

<script>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?79c1a6b70ff1d0b01a24cfd2d8711580";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>

</html>
